---
title: "Multisite Short Run SDA Analysis"
date: 11/01/2019
author: "Marissa Kivi"
---
Sites: Harvard Forest, North Round Pond, Rooster Hill, Goose Egg
Site Inputs: workflow id, observation data

Things to reconsider: 
- how are we deciding our cutoffs for significance, correlation, and good ensembles?
- are there other ways to consider non-linear datasets?

```{R, echo = FALSE, include = FALSE}
rm(list=ls())
library(mvtnorm)
library(PEcAn.workflow)
library(PEcAn.settings)
library(ggplot2)
library(gridExtra)
library(boot)
library(reshape2)
library(dplyr)
library(class)
library(GGally)
library(randomForest)
```

# Step 0: Prepare data

## A. Load data for each site

```{R, echo = FALSE}

# list of site workflow IDs
sites = c(14000000089,14000000090,14000000091, 14000000092)
data.list = list()

# load all datasets for sites 
for (i in seq_along(sites)){
  id = sites[i]
  load(paste0('/data/workflows/PEcAn_',toString(id),'/analysis.Rdata'))
  data.list[[i]] = data
}
```

## B. Prepare data for steps

```{R, echo = F}
# Preliminary organization
param.melt = data.list[[1]]$param.melt
weight.melt = data.list[[1]]$weight.melt
spp = data.list[[1]]$spp
for (i in 2:length(sites)){
  param.melt = rbind(param.melt,data.list[[i]]$param.melt)
  weight.melt = rbind(weight.melt,data.list[[i]]$weight.melt)
  spp = c(spp,data.list[[i]]$spp)
}
# average weights over time
avg.wts = weight.melt %>% group_by(ensemble) %>% summarize(wt = mean(weight))

# unique species
spp = unique(spp)
cutoff = 0.05
good.ensembles = list()

# get good ensembles at each species level 
for (ind in seq_along(spp)){
  this.spp = c()
  s = spp[ind]
  for (i in seq_along(sites)){
    
    # is this species present at this site?
    if (s %in% data.list[[i]]$spp){
      
      # find good ensembles (below bias cutoff) for this species at the site and add to list 
      add = data.list[[i]]$bias.melt %>% group_by(ensemble) %>% 
        summarize(mean.bias = mean(!!sym(s))) %>%
        filter(abs(mean.bias) <= cutoff) %>%
        dplyr::select(ensemble)
      this.spp = c(this.spp, add$ensemble)
    }
  }
  good.ensembles[[ind]] = this.spp
}

# organize run.list by species, not site 
run.list = list()
for (ind in seq_along(spp)){
  
  this.spp = NULL
  s = spp[ind]
  
  for (i in seq_along(sites)){
    # is this species present at the site
    if (s %in% data.list[[i]]$spp){
      
      # if yes, grab the data and add it to the data from other sites
      spp.ind = which(data.list[[i]]$spp == s)
      if (is.null(this.spp)){
        this.spp = data.list[[i]]$run.list[[spp.ind]]
      }else{
        this.spp = rbind(this.spp, data.list[[i]]$run.list[[spp.ind]])
      }
    }
  }
  run.list[[ind]] = this.spp 
}
```

# Step 1: Consider species parameter ranges that lead to inaccurate predictions at the species level

```{R, message=FALSE , warnings=FALSE, echo = FALSE}
imp.pars = list()
# loop through species
for (ind in seq_along(spp)){
  s = spp[ind]
  
  # are there good ensembles for this species? if no, skip 
  if (length(good.ensembles[[ind]]) == 0) next
  
  # filter out species parameter data and format for analysis 
  class = param.melt %>% filter(species == s, p.name == 'DMAX') %>% 
    mutate(class = ifelse(ensemble %in% good.ensembles[[ind]],1,0)) %>%
    dplyr::select(ensemble,class)
  # are there bad ensembles for this species? if no, skip
  if (length(unique(class$class)) == 1) next
  
  data.now = param.melt %>% filter(species == s) %>% dplyr::select(-species, -site) %>%
    dcast(ensemble ~ p.name, fun.aggregate = mean, value.var = 'p.value') %>% 
    left_join(class, by = 'ensemble') %>% dplyr::select(-ensemble)
  
  # perform importance testing on this dataset and print importance values for all parameters
  forest1 = randomForest(factor(class)~., data=data.now)
  vi_imp = importance(forest1)
  vi_sort = sort(vi_imp, decreasing = TRUE, index.return=TRUE)
  vi.df = data.frame(par = rownames(vi_imp)[vi_sort$ix], imp = vi_sort$x)
  imp.pars[[ind]] = vi.df
  print(barplot(vi.df$imp, main = paste(ind,s)))
}
```

```{R, message=FALSE, warnings=FALSE, echo = FALSE}

### ADJUST SCRIPT HERE 
# determine how many parameters to keep for each species; be sure to place zeros for those species that were not plotted 
points = c(1,1,2,1,0,0,1,1,1,0)

# plot each variable found to be important
for (ind in seq_along(spp)){

  # iterate along parameters
  s = spp[ind]
  nvars = points[ind]
  if (nvars == 0) next
  
  for (p in 1:nvars){
    # collect data for parameter 
    name = toString(imp.pars[[ind]]$par[p])
    class = param.melt %>% filter(species == s, p.name == 'DMAX') %>% 
      mutate(class = ifelse(ensemble %in% good.ensembles[[ind]],1,0)) %>%
      dplyr::select(ensemble,class)
    data.now = param.melt %>% filter(species == s, p.name == name) %>% dplyr::select(-species, -site) %>%
      dcast(ensemble ~ p.name, fun.aggregate = mean, value.var = 'p.value') %>% 
      left_join(class, by = 'ensemble') %>% dplyr::select(-ensemble)
    
    # plot
    plt = ggplot(data.now) +
      geom_histogram(aes(x=!!sym(name), fill = as.factor(class))) +
      labs(title = paste(s, name), x = 'parameter value', fill = 'Class')
    print(plt)
  }
}

```

# Step 2: Investigate significant environmental conditions for the productivity of each species

The following steps have been broken down for each species so as to allow for proper evaluation of linear regression assumptions. The assumptions are 
(1) error terms are independent
(2) error terms are Normally-distributed 
(3) equal variance of error term across response variable
(4) error term has mean 0 

## A. Identify non-linear relationships between covariates and the response variable. If a non-linear relationship seems appropriate, transform the specified variable in the transformation adjustment block and re-run the entire block. 


```{R, echo = FALSE, messages = FALSE, warnings = FALSE}
## ADJUST SPECIES HERE
ind = 1
s = spp[ind]

# gather data
data.now = run.list[[ind]] 
data.now$dominant = as.factor(data.now$dominant)
vars = names(data.now)[-c(1,2,5,6,7)]

# select only good ensembles
good.ones = good.ensembles[[ind]]
data.now = data.now %>% filter(ens %in% good.ones)

# create data.trans which contains the transformed data matrix
data.trans = data.now

## ADJUST TRANSFORMATIONS HERE
# adjust variables according to the relationships you see in the plots
data.trans$lat = scale(data.trans$lat)
data.trans$lon = scale(data.trans$lon)
data.trans$pred = scale(data.trans$pred)
data.trans$summer.temp = scale(data.trans$summer.temp)
data.trans$winter.temp = scale(data.trans$winter.temp)
data.trans$summer.precip = scale(data.trans$summer.precip)
data.trans$winter.precip = scale(data.trans$winter.precip)
data.trans$g.season = scale(data.trans$g.season)
data.trans$basal.area = scale(log(data.trans$basal.area))
data.trans$algf25 = scale(data.trans$algf25)
data.trans$algf50 = scale(data.trans$algf50)
data.trans$algf75 = scale(data.trans$algf75)
data.trans$sngf = scale(data.trans$sngf)
data.trans$stand.age = scale(data.trans$stand.age)
data.trans$disturb = scale(data.trans$disturb^(1/3))

dat.pred = data.trans$pred

for (v in 1:length(vars)){
  var = vars[v]
  dat.var = as.matrix(data.trans %>% dplyr::select(var))
  
  # check to make sure it's worth plotting
  if (var == 'dominant' & length(unique(dat.var)) < 2) next
  if (var != 'dominant'){
    if (sd(dat.var,na.rm=TRUE) == 0) next
    if (length(unique(dat.var)) < 2) next
  } 
  
  df = as.data.frame(cbind(dat.pred,dat.var))
  colnames(df) = c('dat.y','dat.x')
  lm.now = lm(dat.y~dat.x, data=df)
  df$resid = lm.now$residuals
  
  pl.lin = ggplot(df) + 
    geom_point(aes(x = dat.x, y = dat.y)) +
    labs(title = paste(var,'vs. Predicted Growth'), x = 'value', y = 'predicted relative annual growth')
  pl.var = ggplot(df) + 
    geom_point(aes(x = dat.x, y = resid)) + 
    labs(title = paste(var,'vs. Model Residual'), x = 'value', y = 'model residual')
  pl.norm = ggplot(df) + 
    geom_histogram(aes(x=dat.x)) + 
    labs(title = paste(var,':: normality plot'), x = 'value', y = 'density')
  
  grid.arrange(pl.lin, pl.var, pl.norm, ncol = 2)
}

```

## B. Perform multiple linear regression analysis to identify significant predictors and interaction terms for species-level annual growth

```{R, echo = FALSE}

data.trans = data.trans %>% dplyr::select(-year,-ens,-bias,-weight)

# if there is only one value for dominant, cannot use in regression
#if (length(unique(data.trans$dominant))<2) data.trans = data.trans %>% dplyr::select(-dominant)
# always remove the dominant covariate for now
data.trans = data.trans %>% dplyr::select(-dominant)

vars = names(data.trans) 
sig.vars = c()
sig.int = list()
trk.int = 1

# compile list of significant individual predictors 
for (v in seq_along(vars)){
  var = vars[v]
  if (var == 'pred') next 
  form = as.formula(paste0('pred~',var))
  mod = lm(form, data = data.trans)
  if (coef(summary(mod))[-1,4] < 0.05) sig.vars = c(sig.vars, var)
}

# compile list of significant interactions
for (v1 in 1:(length(vars)-1)){
  var1 = vars[v1]
  if (var1 == 'pred') next
  
  for (v2 in (v1+1):length(vars)){
    var2 = vars[v2] 
    if (var2 == 'pred') next
    if (var1 == var2) next
    
    form = as.formula(paste0('pred~',var1,'*',var2))
    mod = lm(form, data = data.trans)
    
    # get interaction term values
    term = grep(':',names(coef(summary(mod))[,1]))
    if (length(term)==0) next
     
    # adjust for factor variable (dominants)
    if (var2 == 'dominant' | var1 == 'dominant'){
      if (any(coef(summary(mod))[term,4] < 0.01)){
          sig.int[[trk.int]] = c(var1,var2)
          trk.int = trk.int+1
        }
      }else{
        if (coef(summary(mod))[term,4] < 0.01){
          sig.int[[trk.int]] = c(var1,var2)
          trk.int = trk.int+1
        }
      }
  }
}

# add all identified variables/interactions to a large lm model for re-fitting
# refit the model and only take ones that we have deemed to be important on their own
sing.part = paste(sig.vars, collapse='+')
inter.part = paste(sapply(sig.int, function(x){paste(x,collapse='*')}), collapse = '+')
if (sing.part == '' & inter.part == '') next
if (sing.part != '' & inter.part == '') eq = paste0('pred~',sing.part)
if (sing.part == '' & inter.part != '') eq = paste0('pred~',inter.part)
if (sing.part != '' & inter.part != '') eq = paste0('pred~',sing.part,'+',inter.part)

# now we are interested in looking at which variables seem to be most important to predicting species productivity
mod.full = lm(as.formula(eq), data.trans)
mod.null = lm(pred~1, data.trans)
n = length(data.trans$lat)

# extract only coefficients that are found to be significantly non-zero; organize information in a data frame
final_coefs = coef(summary(mod.full))[-1,]
to_save = which(final_coefs[,4] < 0.05)
to_save_coefs = final_coefs[to_save,1]
to_save_vars = rownames(final_coefs[to_save,])

# make into a dataframe for easier sorting
type = rep('single',length(to_save_vars))
type[grep(':', to_save_vars)] = 'inter'
varname1 = vector()
varname2 = vector()
for (v in seq_along(to_save_vars)){
  term = to_save_vars[v]
  terms = strsplit(term,':')
  varname1[v] = terms[[1]][1]
  varname2[v] = ifelse(is.na(terms[[1]][2]), NA, terms[[1]][2])
}
to_save = data.frame(slope = to_save_coefs, varname1 = varname1,
                     varname2 = varname2, type = type,
                     stringsAsFactors = FALSE) %>% arrange(type,desc(abs(slope)))

```

## C. Generate plots for those single predictors that were found to be significantly non-zero

The importance of each variable as a predictor of productivity is marked by the magnitude of its slope since the covariates were all standardized.  

```{R, echo = FALSE, warnigs = FALSE}

# check to make sure there are predictors
if (length(to_save_vars)==0) next
  
# concatenate all needed predictors
all.terms = unique(c(to_save$varname1,to_save$varname2))
all.terms = all.terms[-c(which(is.na(all.terms)))]
  
# get data 
data.plot = data.now %>% dplyr::select(pred, all.terms)

# the following breaks up the predicted growth into four bins to make plotting cleaner as there are only four colors instead of a spectrum of color
y.min = min(data.plot$pred) 
y.max = max(data.plot$pred)
breaks = c(y.min-0.1, y.min/2, 0, y.max/2, y.max+0.1)
data.plot$breaks = as.factor(.bincode(data.plot$pred,breaks, TRUE))
  
# plot individual sig predictors vs. growth 
sig.terms = to_save %>% filter(type=='single') %>% 
  dplyr::select(-varname2)

if (length(sig.terms$slope) > 0){
  
  for (p in seq_along(sig.terms$slope)){
    
      var.plot = sig.terms$varname1[p]
      importance = sig.terms$slope[p]
      
      pl = ggplot(data.plot, aes_string(x=var.plot,y='pred'), col = 'darkgreen') + 
        geom_point() + 
        geom_smooth(method='lm') + 
        labs(x = var.plot, 
             y = 'predicted growth', 
             title = paste(s,'(',round(importance,3),')'))
      print(pl)
  }
}

# plot parallel coordinates of single parameters
if (length(sig.terms$slope) > 2){
  print(ggparcoord(data = data.plot, columns = 2:(ncol(data.plot)-1), groupColumn = ncol(data.plot), title = paste('Parallel Coordinates ::',s)))
}

```

## D. Generate plots for those interaction relationships that were found to be significantly non-zero

The importance of each term as a predictor of productivity is marked by the magnitude of its slope. 

```{R, echo = FALSE, warnigs = FALSE}
  
# plot interaction terms 
inter.terms = to_save %>% filter(type == 'inter')
if (length(inter.terms$slope) > 0){
  
  for (p in seq_along(inter.terms$slope)){
    var1.plot = inter.terms$varname1[p]
    var2.plot = inter.terms$varname2[p]
    importance = inter.terms$slope[p]
    
    pl = ggplot(data.plot, aes_string(x=var1.plot,y=var2.plot)) +
      geom_point(aes(col=breaks)) +
      labs(x=var1.plot, y=var2.plot, 
           title = paste(s,'(',round(importance,3),')')) + 
      scale_color_manual(values = c('1'='yellow','2'='orange','3'='red','4'='purple'))
    print(pl)
  }
}

```
 
# Step 6: Identify environmental conditions under which LINKAGES performs poorly for each species. 

## A. Consider importance ranking of all environmental variables for predicting accuracy of model forecasts for each species biomass.  

We consider all ensembles in this section.

```{R,message=FALSE, warnings=FALSE, echo = FALSE}

# determine how many variables to consider for each species
# if there is no plot for a species, it signifies that the ensembles that included the species were all considered "accurate" or "inaccurate"

## ADJUST SPECIES HERE
ind = 1
s = spp[ind]

# gather data
data.now = run.list[[ind]] 
data.now$dominant = as.factor(data.now$dominant)
vars = names(data.now)[-c(1,2,5,6,7,19)]

# select only good ensembles for species 
good.ones = good.ensembles[[ind]]
data.now = data.now %>% mutate(class = ifelse(ens %in% good.ones,1,0))

# just remove dominant for now 
#if (length(unique(data6$dominant)) < 2){
#  data6$dominant = as.factor(data6$dominant)
#  data6 = data6 %>% dplyr::select(-ens, -year, -lat, -lon, -pred, -bias, -weight)
#}else{
  data.now = data.now %>% dplyr::select(-ens, -year, -lat, -lon, -pred, -bias, -weight, -dominant)
#  }
  
# are there inaccurate ensembles?
if (length(unique(data.now$class))<2) next
  
# barplot of importance rankings
forest3=randomForest(as.factor(class)~., data=data.now, na.action = na.omit)
vi_imp3 = importance(forest3)
vi_sort3 = sort(vi_imp3, decreasing = TRUE, index.return=TRUE)
vi.df3 = data.frame(par = rownames(vi_imp3)[vi_sort3$ix], imp = vi_sort3$x)
barplot(vi.df3$imp, main = s)

```
Consider barplot to determine how many variables we want to consider further. 

## B. Plot those variables that have been deemed to be "important."

Do we see clear separation in the variable value range between where LINKAGES is predicting correctly and incorrectly?

```{R, message=FALSE, warnings=FALSE, echo = FALSE}

# from the barplots above, determine how many variables we want to keep for each species
cuts = 2

for (j in 1:cuts){
  dat1 = data.now[,vi.df3$par[j]]
  dat2 = data.now$class
  df = data.frame(dat1=dat1,dat2=dat2)
  plt = ggplot(df) + geom_histogram(aes(x=dat1,fill=as.factor(dat2))) +
    labs(title = paste(spp,vi.df3$par[j]), 
         x = 'value', 
         fill = 'class')
  print(plt)
}

```

## C. Consider pairs of environmental variables using importance ranking. 

HACK: Removing factor variable here because it does not work well with multiplication step. 

```{R,message=FALSE, warnings=FALSE, echo = FALSE}

# create matrix to save interaction values 
nvars = length(names(data.now %>% dplyr::select(-class)))
vnames = names(data.now %>% dplyr::select(-class))
df4 = matrix(NA,length(data.now$class),(1+nvars^2))
names = c('class')
df4[,1] = data.now$class
  
# calculate interaction terms and place in matrix 
trk = 2
for (i in 1:(nvars-1)){
  for (j in (i+1):nvars){
    df4[,trk] = data.now[,i] * data.now[,j]
    trk = trk + 1
    
    # get the column name for interaction term 
    names = c(names, paste0(vnames[i],'_',vnames[j]))
  }
}
  
# crop the matrix where the data ends and add tracked column names
df4 = df4[,1:(trk-1)]
colnames(df4) = names
df4 = as.data.frame(df4)

# find importance rankings for each interaction
forest4=randomForest(factor(class)~., data=df4, na.action=na.omit)
vi_imp4 = importance(forest4)
vi_sort4 = sort(vi_imp4, decreasing = TRUE, index.return=TRUE)
vi.df4 = data.frame(par = rownames(vi_imp4)[vi_sort4$ix], imp = vi_sort4$x)
print(barplot(vi.df4$imp, main = s))

```


Consider generated barplot to determine how many interaction terms we want to consider further. Where is the elbow?

## D. Plot those interaction pairs that have been deemed to be "important."

```{r,message=FALSE, warnings=FALSE, echo = FALSE}

# define cutoffs for each species
cuts = 3

# iterate through the important interaction terms and plot
for (i in 1:cuts){
  
  # extract the required variables 
  vars = strsplit(toString(vi.df4$par[i]), split = '_')
  var1 = vars[[1]][1]
  var2 = vars[[1]][2]
    
  # create plot
  pl = ggplot(data = data.now, aes(col=as.factor(class))) +
    geom_point(aes_string(x=var1, y=var2)) + 
    labs(col = 'Class', title = paste(s,'::',var1,'vs.',var2))
  print(pl)
}

```


